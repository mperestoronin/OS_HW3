# На 8 баллов

данный отчет почти полносью дублирует отчет на 6-7 баллов, нововведения можно посмотреть в секции "По поводу нескольких наблюдаетелй:" в самом низу страницы.

*** 1. Серверное приложение:***

Серверное приложение моделирует сад с 40 цветами. Каждый цветок может быть в одном из трех состояний: он может испытывать жажду (состояние 1), быть поливаемым (значение состояние 2) или он может быть политым (состояние 0). Сервер поддерживает двух садовников и двух наблюдателей. (в ТЗ говорилось, о поддержке нескольких наблюдателей, но точное количество не называлось, поэтому я решил ограничиться двумя)

Когда садовник подключается к серверу, сервер выделяет ему цветок для полива. Цветок выбирается из списка испытывающих жажду цветов. Чтобы избежать ситуации, когда два садовника поливают один и тот же цветок, используется мьютекс (взаимное исключение) для каждого цветка.

Когда наблюдатель подключается к серверу, сервер регистрирует его и отправляет ему обновления каждый раз, когда садовник поливает цветок.

***2. Клиент-садовник:***

Садовник подключается к серверу и получает индекс цветка для полива. Затем он "поливает" цветок (эмулируется паузой в одну секунду) и сообщает серверу о завершении полива. Этот процесс повторяется до тех пор, пока все цветы не будут политы.

***3. Клиент-наблюдатель:***

Наблюдатель подключается к серверу и принимает сообщения от сервера о действиях садовников. Он выводит эти обновления в консоль, позволяя нам наблюдать за процессом ухода за садом в реальном времени.

Особенности реализации:

Все приложения написаны на языке программирования C и используют сокеты для обмена сообщениями. Клиенты идентифицируют себя перед сервером с помощью начального сообщения: "gardener" для садовников и "spectator" для наблюдателей.

В сервере используются потоки для одновременного обслуживания нескольких садовников. Мьютексы используются для обеспечения корректного доступа к состоянию каждого цветка и предотвращения ситуации, когда два садовника могут попытаться поливать один и тот же цветок одновременно.

***По поводу нескольких наблюдаетелй:***
После того, как сервер начинает слушать входящие подключения, он входит в бесконечный цикл, где ожидает подключения клиентов и наблюдателей.
Когда сервер принимает новое подключение (с помощью функции accept), он создает новый поток с помощью функции pthread_create.
Каждый поток обслуживает одно подключение и выполняет функцию handle_spectator или handle_gardener.
После завершения работы потока (когда клиент или наблюдатель закрывают соединение), поток завершается, и сервер продолжает принимать новые подключения.
Таким образом, мы можем подключать к серверу много клиентов и наблюдателей одновременно, и каждый из них будет обслуживаться в отдельном потоке. Это дает возможность обрабатывать множество подключений параллельно, что позволяет нам иметь несколько наблюдателей, подключенных к серверу одновременно.
